<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI_JINROU_GAME</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&family=Sawarabi+Gothic&family=Unbounded:wght@400;700;900&display=swap');
      
      body { font-family: 'Sawarabi Gothic', sans-serif; background-color: #e5e5e5; color: #000; overflow: hidden; }
      .font-mono { font-family: 'JetBrains Mono', monospace; }
      .font-unbounded { font-family: 'Unbounded', sans-serif; }
      
      .scrollbar-hide::-webkit-scrollbar { display: none; }
      .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
      
      /* Glitch Effect Keyframes */
      .glitch-active { animation: internalGlitch 0.12s steps(4) forwards; }
      @keyframes internalGlitch { 
        0% { clip-path: inset(0 0 0 0); filter: invert(0); } 
        20% { clip-path: inset(45% 0 5% 0); background: #c5c5c5; } 
        40% { filter: invert(1); } 
        60% { clip-path: inset(10% 0 85% 0); } 
        100% { clip-path: inset(0 0 0 0); filter: invert(0); } 
      }
    </style>

    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">

    /***********************************************************
     * 0. ICONS (Inlined for standalone compatibility)
     ***********************************************************/
    const Icon = ({ path }) => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">{path}</svg>;
    const Icons = {
        Terminal: () => <Icon path={<><polyline points="4 17 10 11 4 5"/><line x1="12" y1="19" x2="20" y2="19"/></>} />,
        Refresh: () => <Icon path={<><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></>} />,
        Send: () => <Icon path={<><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></>} />,
        Download: () => <Icon path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></>} />,
        Check: () => <Icon path={<polyline points="20 6 9 17 4 12"/>} />,
        ArrowLeft: () => <Icon path={<><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></>} />
    };

    /***********************************************************
     * 1. AUDIO & VISUAL ENGINES
     ***********************************************************/
    class AudioManager {
        constructor() { this.ctx = null; this.initialized = false; }
        init() {
            if (this.initialized) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sine'; osc.frequency.value = 42; 
            filter.type = 'lowpass'; filter.frequency.value = 55;
            gain.gain.value = 0.03;
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            osc.start();
            this.initialized = true;
        }
        playFlipSound() {
            if (!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * 0.008; 
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource(); noise.buffer = buffer;
            const filter = this.ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 6200; filter.Q.value = 5.0;
            const gain = this.ctx.createGain(); const now = this.ctx.currentTime;
            gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.008);
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            noise.start();
        }
    }
    const audio = new AudioManager();

    class TopographicEngine {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.numLines = 26; this.tick = 0;
        }
        resize() {
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = window.innerWidth * dpr;
            this.canvas.height = window.innerHeight * dpr;
            this.ctx.scale(dpr, dpr);
        }
        draw() {
            this.tick += 0.003; 
            const w = window.innerWidth; const h = window.innerHeight;
            this.ctx.clearRect(0, 0, w, h);
            for (let i = 0; i < this.numLines; i++) {
                this.ctx.beginPath();
                const distFromCenter = Math.abs(i - this.numLines/2) / (this.numLines/2);
                const opacity = 0.04 + (1 - distFromCenter) * 0.12;
                this.ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
                this.ctx.lineWidth = 0.5 + (1 - distFromCenter) * 1.5;
                for (let x = 0; x <= w; x += 30) {
                    const wave1 = Math.sin(x * 0.0006 + this.tick + i * 0.5) * 80;
                    const wave2 = Math.cos(x * 0.0003 - this.tick * 0.4 + i * 0.8) * 45;
                    const yBase = (h / (this.numLines - 1)) * i;
                    const y = yBase + wave1 + wave2;
                    if (x === 0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
                }
                this.ctx.stroke();
            }
        }
    }

    /***********************************************************
     * 2. LOGIC & CONSTANTS
     ***********************************************************/
    const { useState, useEffect, useRef } = React;
    const generateId = () => Math.random().toString(36).substr(2, 9);
    
    const shuffleArray = (array) => {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    };
    
    const Role = { VILLAGER: 'Villager', WEREWOLF: 'Werewolf', SEER: 'Seer' };
    const ModelProvider = { GEMINI: 'gemini', SILICONFLOW: 'siliconflow', OFFLINE: 'offline' };

    const GEMINI_MODELS = [
        { id: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash', short: 'G-2.5-F' },
        { id: 'gemini-3-flash-preview', name: 'Gemini 3.0 Flash', short: 'G-3.0-F' },
        { id: 'gemini-3-pro-preview', name: 'Gemini 3.0 Pro', short: 'G-3.0-P' },
        { id: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro', short: 'G-2.5-P' }
    ];

    const SILICON_MODELS = [
        { id: 'deepseek-ai/DeepSeek-V3', name: 'DeepSeek V3', short: 'DS-V3' },
        { id: 'deepseek-ai/DeepSeek-R1', name: 'DeepSeek R1', short: 'DS-R1' },
        { id: 'Qwen/Qwen2.5-72B-Instruct', name: 'Qwen 2.5 72B', short: 'Qwen-72B' },
        { id: 'Qwen/Qwen2.5-32B-Instruct', name: 'Qwen 2.5 32B', short: 'Qwen-32B' },
        { id: 'Qwen/Qwen2.5-14B-Instruct', name: 'Qwen 2.5 14B', short: 'Qwen-14B' }, 
        { id: 'internlm/internlm2_5-20b-chat', name: 'InternLM 2.5 20B', short: 'Intern-20B' }, 
        { id: 'google/gemma-2-27b-it', name: 'Gemma 2 27B', short: 'Gemma-27B' }, 
        { id: 'THUDM/glm-4-9b-chat', name: 'GLM-4 9B', short: 'GLM-4' }
    ];

    const FALLBACK_MODEL = 'Qwen/Qwen2.5-14B-Instruct';

    const GamePhase = {
        SETUP: 'SETUP', DAY_INTRO: 'DAY_INTRO', DAY_DISCUSSION: 'DAY_DISCUSSION',
        DAY_VOTE: 'DAY_VOTE', 
        TIE_SPEECH: 'TIE_SPEECH',         
        TIE_DISCUSSION: 'TIE_DISCUSSION', 
        NIGHT_SEER: 'NIGHT_SEER', NIGHT_ACTION: 'NIGHT_ACTION', GAME_OVER: 'GAME_OVER'
    };

    const NAMES = ["Alice", "Bob", "Charlie", "David", "Eve", "Frank", "Grace", "Heidi", "Ivan", "Judy", "Kevin", "Lily"];

    const UI_LABELS = {
      en: {
        title: "AI_WOLF", subtitle: "STABLE_PROTOCOL_V4",
        playerCount: "PLAYER_COUNT", maxRounds: "MAX_ROUNDS", includeSeer: "ENABLE_SEER",
        playAsChar: "ENGAGE_DIRECTLY", yes: "YES", no: "NO (SPECTATE)",
        geminiPlaceholder: "GEMINI_API_KEY", siliconPlaceholder: "SILICONFLOW_API_KEY",
        siliconLabel: "SILICON MODELS:", geminiLabel: "GEMINI MODELS:", devMode: "DEBUG_CONSOLE",
        testConnection: "TEST_LINK", testing: "LINKING...", connectionOk: "OK", connectionFail: "FAIL",
        startGame: "INITIALIZE_GAME", villageLog: "ARCHIVE_LOG",
        chatPlaceholder: "INPUT_DATA...", send: "EXECUTE", dayCount: "CYCLE_{count}",
        votePrompt: "VOTE_TARGET", votingProgress: "VOTING_IN_PROGRESS", 
        killPrompt: "CHOOSING_VICTIM", seerPrompt: "INSPECTING...",
        villagerWin: "VILLAGERS_WIN", werewolfWin: "WEREWOLVES_WIN", playAgain: "REBOOT_SYSTEM",
        you: "YOU", [Role.VILLAGER]: "Villager", [Role.WEREWOLF]: "Werewolf", [Role.SEER]: "Seer",
        gameStarted: "PROTOCOL_START. TOTAL: {total}. WOLVES: {wolves}. SEER: {seer}.",
        discussionEnd: "DISCUSSION_TERMINATED.", roundStart: "--- CYCLE {round} / {total} ---",
        executed: "{name} TERMINATED ({votes} VOTES).", foundDead: "SIGNAL LOST: {name}.",
        missingKeys: "NO_KEYS_DETECTED. STARTING_SIMULATION.", downloadLogs: "SAVE_LOG",
        devConsole: "DEBUGGER", offlineNotice: "OFFLINE_MODE_ACTIVE.", speechError: "CONNECTION_LOST",
        voteSummary: "--- VOTE_RESULTS ---",
        rateLimitWarn: "RETRYING...",
        playerVoted: "{voter} LOCKED_ON {target}",
        roundDisplay: "R: {current}/{max}",
        thinking: "PROCESSING...",
        seerResult: "ðŸ”® RESULT: {name} is {role}.",
        seerDay1Warn: "SYSTEM: DAY_1_RESTRICTION.",
        tieDetected: "âš–ï¸ TIE: {names}. TIE_BREAKER_INIT.",
        tieGlobal: "âš–ï¸ DEADLOCK. EXTENDING_CYCLES.",
        tieSpeech: "ðŸŽ¤ TIE_DEFENSE", tieDiscussion: "ðŸ—£ï¸ JURY_DELIBERATION",
        confirmVote: "CONFIRM_TARGET",
        backHome: "EXIT_PROTOCOL"
      },
      zh: {
        title: "AIç‹¼äººæ€", subtitle: "STABLE_PROTOCOL_V4",
        playerCount: "çŽ©å®¶äººæ•°", maxRounds: "è®¨è®ºè½®æ¬¡", includeSeer: "å¯ç”¨é¢„è¨€å®¶",
        playAsChar: "äº²è‡ªå‚æˆ˜", yes: "æ˜¯", no: "å¦ (è§‚æˆ˜)",
        geminiPlaceholder: "Gemini Key (é€‰å¡«)", siliconPlaceholder: "SiliconFlow Key (æŽ¨è)",
        siliconLabel: "SiliconFlow æ¨¡åž‹:", geminiLabel: "Gemini æ¨¡åž‹:", devMode: "å¼€å‘è€…æ¨¡å¼",
        testConnection: "æµ‹è¯•è¿žæŽ¥", testing: "é“¾æŽ¥ä¸­...", connectionOk: "æ­£å¸¸", connectionFail: "å¤±è´¥",
        startGame: "åˆå§‹åŒ–åè®®", villageLog: "æ¡£æ¡ˆæ—¥å¿—",
        chatPlaceholder: "è¾“å…¥æ•°æ®...", send: "æ‰§è¡Œ", dayCount: "å‘¨æœŸ_{count}",
        votePrompt: "é€‰æ‹©æŠ•ç¥¨ç›®æ ‡", votingProgress: "ç­‰å¾…æŠ•ç¥¨æ•°æ®...", 
        killPrompt: "é€‰æ‹©çŒŽæ€ç›®æ ‡", seerPrompt: "é€‰æ‹©æŸ¥éªŒç›®æ ‡",
        villagerWin: "æ‘åº„èƒœåˆ©", werewolfWin: "ç‹¼äººèƒœåˆ©", playAgain: "é‡å¯ç³»ç»Ÿ",
        you: "ä½ ", [Role.VILLAGER]: "æ‘æ°‘", [Role.WEREWOLF]: "ç‹¼äºº", [Role.SEER]: "é¢„è¨€å®¶",
        gameStarted: "åè®®å·²å¯åŠ¨ã€‚æ€»æ•°: {total}ã€‚ç‹¼äºº: {wolves}ã€‚é¢„è¨€å®¶: {seer}ã€‚",
        discussionEnd: "è®¨è®ºç»ˆæ­¢ï¼Œè¿›å…¥è£å†³ã€‚", roundStart: "--- å‘¨æœŸ {round} / {total} ---",
        executed: "{name} å·²è¢«ç»ˆæ­¢ ({votes}ç¥¨)ã€‚", foundDead: "ä¿¡å·ä¸¢å¤±: {name}ã€‚",
        missingKeys: "æœªæ£€æµ‹åˆ°å¯†é’¥ã€‚å¯åŠ¨æ¨¡æ‹Ÿæ¨¡å¼ã€‚", downloadLogs: "ä¿å­˜æ—¥å¿—",
        devConsole: "åŽå°æ—¥å¿—", offlineNotice: "ç¦»çº¿æ¨¡æ‹Ÿæ¨¡å¼ã€‚", speechError: "âš ï¸ è¿žæŽ¥ä¸­æ–­",
        voteSummary: "--- è£å†³ç»“æžœ ---",
        rateLimitWarn: "â³ é‡è¯•ä¸­...",
        playerVoted: "{voter} é”å®šç›®æ ‡: {target}",
        roundDisplay: "è¿›åº¦: {current}/{max}",
        thinking: "è®¡ç®—ä¸­...",
        seerResult: "ðŸ”® æ‰«æç»“æžœï¼š{name} èº«ä»½ä¸º ã€{role}ã€‘ã€‚",
        seerDay1Warn: "ç³»ç»Ÿè­¦å‘Šï¼šé¦–æ—¥æ— æ•°æ®ã€‚",
        tieDetected: "âš–ï¸ å¹³ç¥¨ä¾¦æµ‹ï¼š{names}ã€‚è¿›å…¥å†³èƒœç¨‹åºã€‚",
        tieGlobal: "âš–ï¸ å…¨å‘˜åƒµå±€ã€‚åŠ èµ›ä¸¤è½®ã€‚",
        tieSpeech: "ðŸŽ¤ PKå°: è¾©æŠ¤", tieDiscussion: "ðŸ—£ï¸ PKå°: å®¡åˆ¤",
        confirmVote: "ç¡®è®¤å¤„å†³",
        backHome: "è¿”å›žä¸»é¡µ"
      },
      ja: {
        title: "AIäººç‹¼", subtitle: "STABLE_PROTOCOL_V4",
        playerCount: "äººæ•°", maxRounds: "è­°è«–å›žæ•°", includeSeer: "é è¨€è€…æœ‰åŠ¹",
        playAsChar: "ç›´æŽ¥å‚åŠ ", yes: "ã¯ã„", no: "è¦³æˆ¦",
        geminiPlaceholder: "Gemini Key", siliconPlaceholder: "SiliconFlow Key",
        siliconLabel: "SFãƒ¢ãƒ‡ãƒ«:", geminiLabel: "Geminiãƒ¢ãƒ‡ãƒ«:", devMode: "é–‹ç™ºãƒ¢ãƒ¼ãƒ‰",
        testConnection: "æŽ¥ç¶šãƒ†ã‚¹ãƒˆ", testing: "ãƒ†ã‚¹ãƒˆä¸­...", connectionOk: "æ­£å¸¸", connectionFail: "å¤±æ•—",
        startGame: "ãƒ—ãƒ­ãƒˆã‚³ãƒ«é–‹å§‹", villageLog: "ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ»ãƒ­ã‚°",
        chatPlaceholder: "ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›...", send: "é€ä¿¡", dayCount: "ã‚µã‚¤ã‚¯ãƒ«_{count}",
        votePrompt: "æŠ•ç¥¨å…ˆã‚’é¸æŠž", votingProgress: "æŠ•ç¥¨ãƒ‡ãƒ¼ã‚¿å—ä¿¡ä¸­...", 
        killPrompt: "æŽ’é™¤å¯¾è±¡ã‚’é¸æŠž", seerPrompt: "ã‚¹ã‚­ãƒ£ãƒ³å¯¾è±¡ã‚’é¸æŠž",
        villagerWin: "æ‘äººå‹åˆ©", werewolfWin: "äººç‹¼å‹åˆ©", playAgain: "å†èµ·å‹•",
        you: "ã‚ãªãŸ", [Role.VILLAGER]: "æ‘äºº", [Role.WEREWOLF]: "äººç‹¼", [Role.SEER]: "é è¨€è€…",
        gameStarted: "ãƒ—ãƒ­ãƒˆã‚³ãƒ«é–‹å§‹ã€‚åˆè¨ˆ: {total}ã€‚äººç‹¼: {wolves}ã€‚é è¨€è€…: {seer}ã€‚",
        discussionEnd: "è­°è«–çµ‚äº†ã€‚", roundStart: "--- Cycle {round} / {total} ---",
        executed: "{name} ã‚’æŽ’é™¤ ({votes}ç¥¨)ã€‚", foundDead: "é€šä¿¡é€”çµ¶: {name}ã€‚",
        missingKeys: "ã‚­ãƒ¼æœªæ¤œå‡ºã€‚ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰èµ·å‹•ã€‚", downloadLogs: "ãƒ­ã‚°ä¿å­˜",
        devConsole: "ãƒ‡ãƒãƒƒã‚°", offlineNotice: "ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã€‚", speechError: "âš ï¸ ã‚¨ãƒ©ãƒ¼",
        voteSummary: "--- æŠ•ç¥¨çµæžœ ---",
        rateLimitWarn: "â³ å†è©¦è¡Œä¸­...",
        playerVoted: "{voter} ã¯ {target} ã‚’ãƒ­ãƒƒã‚¯ã‚ªãƒ³",
        roundDisplay: "Round {current}/{max}",
        thinking: "æ¼”ç®—ä¸­...",
        seerResult: "ðŸ”® ã‚¹ã‚­ãƒ£ãƒ³çµæžœï¼š{name} ï¼ ã€{role}ã€‘ã€‚",
        seerDay1Warn: "ã‚·ã‚¹ãƒ†ãƒ ï¼šåˆæ—¥ãƒ‡ãƒ¼ã‚¿ãªã—ã€‚",
        tieDetected: "âš–ï¸ åŒç¥¨æ¤œçŸ¥: {names}ã€‚æ±ºæˆ¦ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã€‚",
        tieGlobal: "âš–ï¸ å…¨å“¡åŒç¥¨ã€‚è­°è«–å»¶é•·ã€‚",
        tieSpeech: "ðŸŽ¤ å¼æ˜Ž", tieDiscussion: "ðŸ—£ï¸ é™ªå¯©å“¡è­°è«–",
        confirmVote: "æŠ•ç¥¨ç¢ºå®š",
        backHome: "ãƒ›ãƒ¼ãƒ ã¸"
      }
    };

    /***********************************************************
     * 3. AI SERVICES (FIXED)
     ***********************************************************/
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    const cleanThink = (text) => text.replace(/<think>[\s\S]*?<\/think>/g, '').trim().replace(/^['"]|['"]$/g, '');
    const buildContext = (logs) => logs.slice(-25).map(l => {
        if(l.type === 'vote_summary') return `[SYSTEM] Voting Results: ${l.text}`;
        if(l.type === 'system') return `[SYSTEM] ${l.text}`;
        return `[SPEAKER: ${l.senderName}]: ${l.text}`;
    }).join('\n');

    const fetchWithRetry = async (url, options, retries = 3, backoff = 2000) => {
        for (let i = 0; i < retries; i++) {
            try {
                const res = await fetch(url, options);
                if (res.status === 429) throw new Error("429 Too Many Requests");
                if (!res.ok) { 
                    const errText = await res.text(); 
                    let errMsg = `HTTP ${res.status}`;
                    try {
                        const errJson = JSON.parse(errText);
                        if (errJson.error && errJson.error.message) errMsg += `: ${errJson.error.message}`;
                        else errMsg += `: ${errText}`;
                    } catch(e) { errMsg += `: ${errText}`; }
                    throw new Error(errMsg); 
                }
                return res;
            } catch (err) {
                if (i < retries - 1) { await delay(backoff); backoff *= 2; } else { throw err; }
            }
        }
    };

    // *** FIX: Added default config={} to prevent undefined access error ***
    const callApi = async (provider, apiKey, config = {}, prompt, systemInfo) => {
        const performFetch = async (modelId) => {
            if (provider === ModelProvider.GEMINI) {
                // *** FIX 1: DYNAMIC URL for Gemini based on modelId (Defaults to 2.5 Flash) ***
                const targetModel = modelId || 'gemini-2.5-flash';
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${targetModel}:generateContent?key=${apiKey.trim()}`;
                
                const isPing = prompt === "Ping";
                const body = { 
                    contents: [{ parts: [{ text: prompt }] }]
                };
                
                if (!isPing) {
                    body.systemInstruction = { parts: [{ text: systemInfo || "" }] };
                    body.safetySettings = [
                        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                    ];
                }

                // *** FIX 2: Simplified headers. Removed 'credentials: omit' which some environments dislike. ***
                try {
                    const res = await fetchWithRetry(url, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(body)
                    });
                    const data = await res.json();
                    
                    if (!data.candidates || !data.candidates[0].content) {
                        console.warn("Gemini Response Empty:", data);
                        return "...";
                    }
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
                } catch (fetchErr) {
                    // *** FIX 3: Explicit ALERT for errors to bypass system toast suppression ***
                    if (isPing) alert(`GEMINI CONNECT ERROR:\n${fetchErr.message}\nModel: ${targetModel}`);
                    throw fetchErr;
                }
            } 
            else if (provider === ModelProvider.SILICONFLOW) {
                const res = await fetchWithRetry("https://api.siliconflow.cn/v1/chat/completions", {
                    method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey.trim()}` },
                    body: JSON.stringify({ model: modelId, messages: [{ role: "system", content: systemInfo }, { role: "user", content: prompt }], stream: false, max_tokens: 400, temperature: 0.8 })
                });
                const data = await res.json();
                return data.choices[0].message.content;
            }
        };

        try {
            return await performFetch(config?.modelId);
        } catch (e) {
            console.warn(`[API FAIL] Model ${config?.modelId || 'Unknown'} failed. Error: ${e}`);
            if (provider === ModelProvider.SILICONFLOW && config.modelId !== FALLBACK_MODEL) {
                try { return await performFetch(FALLBACK_MODEL); } catch (e2) { throw e2; }
            }
            throw e;
        }
    };

    const LLMService = {
        testConnection: async (apiKey, provider, config) => {
             if (provider === ModelProvider.OFFLINE) return { success: true };
             // *** FIX: Pass empty config to prevent undefined error ***
             try { await callApi(provider, apiKey, config || {}, "Ping", "Pong"); return { success: true }; } 
             catch (e) { return { success: false, error: String(e) }; }
        },
        
        generateSpeech: async (player, allPlayers, logs, keys, language, gameInfo, privateMemory, waitingPlayers, phaseType, tiedPlayersNames, onDebug) => {
            if (player.provider === ModelProvider.OFFLINE) {
                await delay(500); return ["ðŸ¤” Hmm...", "ðŸ˜ I am Villager.", "ðŸ˜  Wolf is among us."][Math.floor(Math.random()*3)];
            }
            const context = buildContext(logs);
            const langName = { 'zh': 'Chinese (ç®€ä½“ä¸­æ–‡)', 'ja': 'Japanese (æ—¥æœ¬èªž)', 'en': 'English' }[language] || 'English';
            
            let dayContext = gameInfo.day === 1 ? `It is DAY 1. NO events happened last night. Players [${waitingPlayers.join(', ')}] have not spoken.` : `It is Day ${gameInfo.day}. Game continues.`;
            let specialPhaseInstr = "";
            if (phaseType === GamePhase.TIE_SPEECH) specialPhaseInstr = `[URGENT]: You are TIED! Final Defense vs ${tiedPlayersNames}.`;
            else if (phaseType === GamePhase.TIE_DISCUSSION) specialPhaseInstr = `[URGENT]: TIE between [${tiedPlayersNames}]. Discuss who to eliminate.`;

            let roleInfo = `ROLE: ${player.role}.`;
            let privateContext = "";
            if(player.role === Role.SEER && privateMemory?.length) privateContext = `\n[PAST INSPECTIONS]:\n${privateMemory.join('\n')}`;

            const prompt = `
            GAME: ${gameInfo.total}p. ${gameInfo.wolves} Wolves. ${dayContext} ${specialPhaseInstr}
            Me: ${player.name}. History: ${context} ${privateContext} ${roleInfo}
            Task: Speak to village in ${langName}. Start with Emoji. Max 40 words. No filler.`; 

            try {
                let apiKey = keys.silicon; let config = { modelId: player.modelId };
                if (player.provider === ModelProvider.GEMINI) { apiKey = keys.gemini; config = { modelId: player.modelId }; }
                
                // *** FIX: Added Debug Log ***
                if(onDebug) onDebug(`${player.name} Prompt`, `Generating Speech`, prompt);

                const res = await callApi(player.provider, apiKey, config, prompt, `You are ${player.name}. Speak ${langName}.`);
                return cleanThink(res);
            } catch (e) { return "ðŸ¤ ... (CONNECTION_LOST)"; }
        },

        generateVote: async (player, allPlayers, logs, keys, language, gameInfo, privateMemory, tiedPlayers, onDebug) => {
             let candidates = [];
             if (tiedPlayers && tiedPlayers.length > 0) candidates = allPlayers.filter(p => tiedPlayers.includes(p.id) && p.id !== player.id);
             else candidates = allPlayers.filter(p => p.isAlive && p.id !== player.id);

             if (player.provider === ModelProvider.OFFLINE) { await delay(500); return { targetId: candidates[0]?.id, reason: "Sim" }; }

             const prompt = `My Name: ${player.name}. Role: ${player.role}. Valid Candidates: ${candidates.map(p=>p.name).join(', ')}. History: ${buildContext(logs)}. Return JSON: { "targetName": "Name", "reason": "Text" }`;

             try {
                let apiKey = keys.silicon; let config = { modelId: player.modelId };
                if (player.provider === ModelProvider.GEMINI) { apiKey = keys.gemini; config = { modelId: player.modelId }; }
                
                // *** FIX: Added Debug Log ***
                if(onDebug) onDebug(`${player.name} Vote Prompt`, `Voting`, prompt);

                const raw = await callApi(player.provider, apiKey, config, prompt, "JSON generator");
                const clean = cleanThink(raw).replace(/```json/g, '').replace(/```/g, '').trim();
                let parsed = JSON.parse(clean.match(/\{[\s\S]*\}/)?.[0] || "{}");
                let target = candidates.find(c => c.name.includes(parsed.targetName));
                if (!target) { target = candidates[Math.floor(Math.random() * candidates.length)]; parsed.reason = "Fallback Decision"; }
                return { targetId: target.id, reason: parsed.reason };
             } catch { return { targetId: candidates[0].id, reason: "Error" }; }
        },
        
        generateNightAction: async (player, allPlayers, logs, keys, language, gameInfo, onDebug) => {
            const candidates = allPlayers.filter(p => p.isAlive && p.role !== Role.WEREWOLF);
            if (!candidates.length) return null;
            if (player.provider === ModelProvider.OFFLINE) return candidates[0].id;
            const prompt = `Targets: ${candidates.map(p=>p.name).join(',')}. Pick one to KILL. Return JSON: { "targetName": "Name" }`;
            try {
                let apiKey = keys.silicon; let config = { modelId: player.modelId };
                if (player.provider === ModelProvider.GEMINI) { apiKey = keys.gemini; config = { modelId: player.modelId }; }
                
                // *** FIX: Added Debug Log ***
                if(onDebug) onDebug(`${player.name} Kill Prompt`, `Choosing victim`, prompt);

                const raw = await callApi(player.provider, apiKey, config, prompt, "JSON generator");
                const parsed = JSON.parse(cleanThink(raw).match(/\{[\s\S]*\}/)?.[0] || "{}");
                const target = candidates.find(c => c.name.includes(parsed.targetName));
                return target ? target.id : candidates[0].id;
            } catch { return candidates[0].id; }
        },

        generateSeerAction: async (player, allPlayers, logs, keys, language, gameInfo, inspectedHistory, onDebug) => {
            const candidates = allPlayers.filter(p => p.isAlive && p.id !== player.id && !inspectedHistory.includes(p.id));
            if (!candidates.length) return null; 
            if (player.provider === ModelProvider.OFFLINE) return candidates[0].id;
            const prompt = `You are SEER. Candidates: ${candidates.map(p=>p.name).join(',')}. Pick one to INSPECT. Return JSON: { "targetName": "Name" }`;
            try {
                let apiKey = keys.silicon; let config = { modelId: player.modelId };
                if (player.provider === ModelProvider.GEMINI) { apiKey = keys.gemini; config = { modelId: player.modelId }; }
                
                // *** FIX: Added Debug Log ***
                if(onDebug) onDebug(`${player.name} Seer Prompt`, `Inspecting`, prompt);

                const raw = await callApi(player.provider, apiKey, config, prompt, "JSON generator");
                const parsed = JSON.parse(cleanThink(raw).match(/\{[\s\S]*\}/)?.[0] || "{}");
                const target = candidates.find(c => c.name.includes(parsed.targetName));
                return target ? target.id : candidates[Math.floor(Math.random()*candidates.length)].id;
            } catch { return candidates[0].id; }
        }
    };

    /***********************************************************
     * 4. UI COMPONENTS (STYLED)
     ***********************************************************/
    
    // *** FIX: Updated PlayerCard to Polaroid Style ***
    const PlayerCard = ({ player, isSpeaking, isThinking, revealRole, onClick, language }) => {
        const t = UI_LABELS[language];
        const [glitch, setGlitch] = useState(false);
        const handleEnter = () => {
            audio.playFlipSound();
            if (Math.random() > 0.05) { setGlitch(true); setTimeout(() => setGlitch(false), 120); }
        };

        return (
            <div 
                onClick={onClick} 
                onMouseEnter={handleEnter} 
                className={`relative bg-white p-3 pb-8 shadow-[0_8px_16px_rgba(0,0,0,0.15)] transition-all duration-300 flex flex-col items-center gap-2 cursor-pointer
                ${!player.isAlive ? 'grayscale opacity-60' : ''}
                ${isSpeaking ? 'z-20 scale-110 rotate-0 shadow-[0_20px_40px_rgba(0,0,0,0.3)]' : 'hover:scale-105 hover:rotate-0 hover:z-10'}
                ${glitch ? 'glitch-active' : ''}
                `}
                style={{ 
                    transform: isSpeaking ? 'scale(1.1) rotate(0deg)' : `rotate(${player.rotation || 0}deg)`
                }}
            >
                {/* Polaroid Image Area */}
                <div className="relative w-full aspect-square bg-gray-100 border border-gray-200 overflow-hidden">
                    <img src={player.avatarUrl} alt={player.name} className="w-full h-full object-cover" />
                    {!player.isAlive && <div className="absolute inset-0 bg-black/60 flex items-center justify-center font-black text-white text-3xl font-unbounded">LOST</div>}
                    {isThinking && <div className="absolute inset-0 bg-black/10 flex items-center justify-center"><div className="w-8 h-8 border-4 border-black border-t-transparent animate-spin"></div></div>}
                    {player.isHuman && <div className="absolute top-1 right-1 bg-black text-white text-[8px] px-2 py-0.5 font-unbounded font-bold">YOU</div>}
                </div>

                {/* Polaroid Caption Area */}
                <div className="text-center w-full mt-1">
                    <div className="font-unbounded font-black text-[12px] uppercase truncate tracking-tighter text-black">{player.name}</div>
                    <div className="text-[8px] font-unbounded opacity-60 uppercase text-gray-600">{!player.isHuman ? (player.modelShort || 'SIM') : 'USER'}</div>
                    {revealRole && <div className={`mt-1 text-[8px] px-1 py-0.5 font-unbounded font-black uppercase inline-block ${player.role === Role.WEREWOLF ? 'bg-red-600 text-white' : player.role === Role.SEER ? 'bg-purple-600 text-white' : 'bg-green-600 text-white'}`}>{t[player.role]}</div>}
                </div>
            </div>
        );
    };

    // *** FIX: Improved DevConsole with correct width and details element support ***
    const DevConsole = ({ logs, t }) => {
        const downloadLogs = () => {
            const content = logs.map(l => `[${l.timestamp}] ${l.action}: ${l.explanation}\n${l.details||''}`).join('\n\n---\n\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `archive_log_${Date.now()}.txt`; a.click();
        };
        const bottomRef = useRef(null);
        useEffect(() => { bottomRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [logs]);
        return (
            <div className="w-80 bg-black text-[#0f0] font-mono text-[10px] border-l-4 border-black flex flex-col h-full z-50 shadow-[-10px_0_20px_rgba(0,0,0,0.2)]">
                <div className="p-3 border-b border-[#0f0]/30 flex justify-between items-center bg-[#0f0]/10">
                    <span className="font-unbounded font-black uppercase tracking-widest text-xs">DEBUG_STREAM</span>
                    <button onClick={downloadLogs} className="hover:bg-[#0f0] hover:text-black px-2 py-1 transition-colors uppercase font-bold text-[9px] border border-[#0f0]">SAVE_LOG</button>
                </div>
                <div className="flex-1 overflow-y-auto p-2 space-y-2 scrollbar-hide">
                    {logs.map(log => (
                        <div key={log.id} className="border border-[#0f0]/30 p-2 bg-[#0f0]/5">
                            <div className="opacity-50 text-[8px] mb-1">{log.timestamp}</div>
                            <div className="font-bold text-[#0f0] mb-1 text-[11px]">[{log.action}]</div>
                            <div className="mb-2 opacity-90">{log.explanation}</div>
                            {log.details && (
                                <details>
                                    <summary className="cursor-pointer text-[#0f0]/70 hover:text-[#0f0] underline decoration-dotted">PAYLOAD_DATA</summary>
                                    <div className="mt-2 border-t border-[#0f0]/20 pt-2 text-[#0f0]/80 whitespace-pre-wrap break-all bg-black/50 p-1">
                                        {log.details}
                                    </div>
                                </details>
                            )}
                        </div>
                    ))}
                    <div ref={bottomRef} />
                </div>
            </div>
        );
    };

    /***********************************************************
     * 5. MAIN APP
     ***********************************************************/
    const App = () => {
        const [config, setConfig] = useState({
            playerCount: 6, maxRounds: 3, includeSeer: true,
            geminiKey: '', siliconKey: '', 
            siliconModels: ['deepseek-ai/DeepSeek-V3'],
            geminiModels: ['gemini-2.5-flash'],
            humanPlayerId: 'yes', language: 'ja', devMode: false
        });
        const [phase, setPhase] = useState(GamePhase.SETUP);
        const [dayCount, setDayCount] = useState(1);
        const [players, setPlayers] = useState([]);
        const [logs, setLogs] = useState([]);
        const [devLogs, setDevLogs] = useState([]);
        const [roundCount, setRoundCount] = useState(0);
        const [currentSpeakerIndex, setCurrentSpeakerIndex] = useState(0);
        const [winner, setWinner] = useState(null);
        const [humanInput, setHumanInput] = useState('');
        const [isHumanTurn, setIsHumanTurn] = useState(false);
        const [apiStatus, setApiStatus] = useState('idle');
        const [testStatusMsg, setTestStatusMsg] = useState('');
        
        const [selectedVoteTarget, setSelectedVoteTarget] = useState(null); 
        
        // Tie Breaker States
        const [tiedPlayers, setTiedPlayers] = useState([]);
        const [thinkingPlayerId, setThinkingPlayerId] = useState(null);
        const [aiMemories, setAiMemories] = useState({}); 
        const [inspectedHistory, setInspectedHistory] = useState([]); 

        const canvasRef = useRef(null);
        const engineRef = useRef(null);
        const isProcessingTurn = useRef(false);
        const t = UI_LABELS[config.language];

        useEffect(() => {
            if (canvasRef.current) {
                engineRef.current = new TopographicEngine(canvasRef.current);
                engineRef.current.resize();
                const animate = () => { engineRef.current.draw(); requestAnimationFrame(animate); };
                animate();
                window.addEventListener('resize', () => engineRef.current?.resize());
            }
        }, [phase === GamePhase.SETUP]);

        const addLog = (text, type, senderName='GM', senderId='GM') => setLogs(p => [...p, { id: generateId(), text, type, senderName, senderId }]);
        const addDevLog = (action, explanation, details='') => {
            if(!config.devMode) return;
            const time = new Date().toLocaleTimeString();
            setDevLogs(p => [...p, { id: generateId(), timestamp: time, action, explanation, details }]);
        };
        const updateApiStatus = (status) => setApiStatus(status);
        
        const toggleModel = (id) => {
            setConfig(prev => {
                const newSet = new Set(prev.siliconModels);
                if (newSet.has(id)) { if(newSet.size > 1) newSet.delete(id); } 
                else newSet.add(id);
                return { ...prev, siliconModels: Array.from(newSet) };
            });
        };
        
        const toggleGeminiModel = (id) => {
            setConfig(prev => {
                const newSet = new Set(prev.geminiModels);
                if (newSet.has(id)) { if(newSet.size > 1) newSet.delete(id); } 
                else newSet.add(id);
                return { ...prev, geminiModels: Array.from(newSet) };
            });
        };

        const testConnection = async () => {
            setTestStatusMsg(t.testing);
            let results = [];
            const geminiKey = config.geminiKey.trim();
            if(geminiKey) { 
                // *** FIX: Use a selected model or default to 2.5 flash for test ***
                const mId = config.geminiModels[0] || 'gemini-2.5-flash';
                const r = await LLMService.testConnection(geminiKey, ModelProvider.GEMINI, { modelId: mId }); 
                results.push(r.success ? 'Gemini OK' : `Gemini Fail [${r.error}]`); 
            }
            if(config.siliconKey) { 
                const r = await LLMService.testConnection(config.siliconKey, ModelProvider.SILICONFLOW, { modelId: config.siliconModels[0] }); 
                results.push(r.success ? 'SiliconFlow OK' : `SiliconFlow Fail [${r.error}]`); 
            }
            setTestStatusMsg(results.length ? results.join(' | ') : t.missingKeys);
        };

        // *** FIX: Restart Function to prevent Gray Screen/Crash ***
        const restartGame = () => {
            setPhase(GamePhase.SETUP);
            setLogs([]);
            setPlayers([]);
            setDevLogs([]);
            setWinner(null);
            setDayCount(1);
            setRoundCount(0);
            setHumanInput('');
            setIsHumanTurn(false);
            setApiStatus('idle');
            setTiedPlayers([]);
            setAiMemories({});
            setInspectedHistory([]);
            setTestStatusMsg('');
            // We do NOT reset config (API keys, etc.) so user doesn't have to re-enter them
        };

        const startGame = () => {
            audio.init();
            const hasApi = config.geminiKey.trim() || config.siliconKey;
            let useOffline = !hasApi;
            if(!hasApi && !confirm(t.missingKeys)) return;

            isProcessingTurn.current=false; updateApiStatus('idle'); setDevLogs([]); setAiMemories({}); setInspectedHistory([]);
            
            let wc = 1;
            if (config.playerCount >= 10) wc = 3; else if (config.playerCount >= 7) wc = 2;
            const roles = Array(wc).fill(Role.WEREWOLF);
            if(config.includeSeer) roles.push(Role.SEER);
            while(roles.length < config.playerCount) roles.push(Role.VILLAGER);
            
            shuffleArray(roles);
            const avProviders = [];
            if(useOffline) avProviders.push(ModelProvider.OFFLINE);
            else {
                if(config.geminiKey.trim()) avProviders.push(ModelProvider.GEMINI);
                if(config.siliconKey) avProviders.push(ModelProvider.SILICONFLOW);
            }
            
            const newPlayers = [];
            for(let i=0; i<config.playerCount; i++) {
                const isHuman = config.humanPlayerId === 'yes' && i===0;
                let provider = isHuman ? null : avProviders[Math.floor(Math.random()*avProviders.length)];
                newPlayers.push({ 
                    id: generateId(), name: NAMES[i], role: roles[i], isHuman, isAlive: true, provider, 
                    avatarUrl: `https://picsum.photos/seed/${NAMES[i]}/200`, modelId: null, modelShort: null,
                    // *** FIX: Add Random Rotation for Polaroid Style ***
                    rotation: (Math.random() * 6 - 3).toFixed(1)
                });
            }

            const siliconPlayers = newPlayers.filter(p => !p.isHuman && p.provider === ModelProvider.SILICONFLOW);
            if (siliconPlayers.length > 0) {
                let modelPool = [];
                while (modelPool.length < siliconPlayers.length) modelPool = [...modelPool, ...config.siliconModels];
                shuffleArray(modelPool);
                siliconPlayers.forEach((p, index) => {
                    const mId = modelPool[index];
                    const mObj = SILICON_MODELS.find(m => m.id === mId);
                    p.modelId = mId; p.modelShort = mObj ? mObj.short : 'SF';
                });
            }

            // *** FIX: Distribute GEMINI Models ***
            const geminiPlayers = newPlayers.filter(p => !p.isHuman && p.provider === ModelProvider.GEMINI);
            if (geminiPlayers.length > 0) {
                let modelPool = [];
                while (modelPool.length < geminiPlayers.length) modelPool = [...modelPool, ...config.geminiModels];
                shuffleArray(modelPool);
                geminiPlayers.forEach((p, index) => {
                     const mId = modelPool[index];
                     const mObj = GEMINI_MODELS.find(m => m.id === mId);
                     p.modelId = mId; p.modelShort = mObj ? mObj.short : 'GEMINI';
                });
            }

            setPlayers(newPlayers); setPhase(GamePhase.DAY_INTRO); setDayCount(1); setLogs([]);
            if(useOffline) addLog(t.offlineNotice, 'system');
            
            const seerTxt = config.includeSeer ? t.yes : t.no;
            addLog(t.gameStarted.replace('{total}', config.playerCount).replace('{wolves}', wc).replace('{seer}', seerTxt), 'system');
            
            setTimeout(() => {
                 setPhase(GamePhase.DAY_DISCUSSION); setRoundCount(1);
                 const first = newPlayers.findIndex(p=>p.isAlive); setCurrentSpeakerIndex(first>-1?first:0);
            }, 1000);
        };

        const checkWin = (cps) => {
             const aw = cps.filter(p=>p.isAlive && p.role===Role.WEREWOLF).length;
             const av = cps.filter(p=>p.isAlive && p.role!==Role.WEREWOLF).length;
             if(aw===0) { setWinner(Role.VILLAGER); setPhase(GamePhase.GAME_OVER); addLog(t.villagerWin, 'system'); return true; }
             if(aw>=av) { setWinner(Role.WEREWOLF); setPhase(GamePhase.GAME_OVER); addLog(t.werewolfWin, 'system'); return true; }
             return false;
        };

        const advanceTurn = (currIdx, currPlayers) => {
             let next = (currIdx+1)%currPlayers.length;
             let loop=0;
             while(!currPlayers[next].isAlive && loop<currPlayers.length) { next=(next+1)%currPlayers.length; loop++; }
             if(loop>=currPlayers.length) return;
             if(next < currIdx) {
                 if (phase === GamePhase.DAY_DISCUSSION) {
                     const nr = roundCount+1;
                     if(nr > config.maxRounds) { setPhase(GamePhase.DAY_VOTE); addLog(t.discussionEnd, 'system'); return; }
                     setRoundCount(nr); addLog(t.roundStart.replace('{round}', nr).replace('{total}', config.maxRounds), 'system');
                 } else if (phase === GamePhase.TIE_SPEECH) {
                     setPhase(GamePhase.TIE_DISCUSSION); setRoundCount(1);
                     addLog(t.tieDiscussion.replace('(Spectators Only)', ''), 'system'); 
                     addLog(`[SYSTEM] TIED/SILENCED: ${tiedPlayers.map(id => players.find(p=>p.id===id)?.name).join(', ')}`, 'system');
                     let startIdx = 0;
                     while(startIdx < players.length) {
                         const p = players[startIdx];
                         if (p.isAlive && !tiedPlayers.includes(p.id)) break;
                         startIdx++;
                     }
                     setCurrentSpeakerIndex(startIdx);
                     return;
                 } else if (phase === GamePhase.TIE_DISCUSSION) {
                     const nr = roundCount + 1;
                     if (nr > 2) { setPhase(GamePhase.DAY_VOTE); addLog(t.discussionEnd, 'system'); return; }
                     setRoundCount(nr);
                 }
             }
             setCurrentSpeakerIndex(next);
        };

        const getKeys = () => ({ gemini: config.geminiKey.trim(), silicon: config.siliconKey });
        const getGameInfo = () => {
            let wc = config.playerCount >= 10 ? 3 : config.playerCount >= 7 ? 2 : 1;
            return { total: config.playerCount, wolves: wc, day: dayCount, hasSeer: config.includeSeer };
        };

        useEffect(() => {
             const validPhases = [GamePhase.DAY_DISCUSSION, GamePhase.TIE_SPEECH, GamePhase.TIE_DISCUSSION];
             if(!validPhases.includes(phase) || !players.length) return;
             
             const p = players[currentSpeakerIndex];
             if(!p?.isAlive) { advanceTurn(currentSpeakerIndex, players); return; }
             if (phase === GamePhase.TIE_DISCUSSION && tiedPlayers.includes(p.id)) { advanceTurn(currentSpeakerIndex, players); return; }
             if (phase === GamePhase.TIE_SPEECH && !tiedPlayers.includes(p.id)) { advanceTurn(currentSpeakerIndex, players); return; }
             
             const run = async () => {
                 if(isProcessingTurn.current) return;
                 isProcessingTurn.current=true;
                 try {
                     if(p.isHuman) { setIsHumanTurn(true); isProcessingTurn.current=false; }
                     else {
                         setIsHumanTurn(false);
                         const isOnline = p.provider !== ModelProvider.OFFLINE;
                         setThinkingPlayerId(p.id);
                         await delay(isOnline ? 3000 : 500); 
                         updateApiStatus('working');
                         
                         const myMemory = aiMemories[p.id] || [];
                         let waiting = [];
                         if (phase === GamePhase.DAY_DISCUSSION) {
                             for(let i=currentSpeakerIndex+1; i<players.length; i++) if(players[i].isAlive) waiting.push(players[i].name);
                         }
                         const tiedNames = tiedPlayers.map(id => players.find(pl=>pl.id===id)?.name).join(', ');
                         const text = await LLMService.generateSpeech(p, players, logs, getKeys(), config.language, getGameInfo(), myMemory, waiting, phase, tiedNames, addDevLog);
                         
                         setThinkingPlayerId(null); updateApiStatus('success');
                         addLog(text, 'speech', p.name, p.id);
                         isProcessingTurn.current=false;
                         advanceTurn(currentSpeakerIndex, players);
                     }
                 } catch(e) {
                     setThinkingPlayerId(null); updateApiStatus('error'); isProcessingTurn.current=false; advanceTurn(currentSpeakerIndex, players);
                 }
             };
             run();
        }, [phase, currentSpeakerIndex, roundCount]);

        useEffect(() => {
             if(phase===GamePhase.DAY_VOTE) {
                 const humanAlive = players.some(p=>p.isHuman && p.isAlive);
                 const humanIsTied = humanAlive && tiedPlayers.includes(players.find(p=>p.isHuman).id);
                 if(!humanAlive || humanIsTied) handleVoteProcess("AUTO");
             }
        }, [phase]);

        const handleVoteProcess = async (humanVoteId) => {
             const votes = {};
             if(humanVoteId!=="AUTO" && players.find(p=>p.isHuman)?.isAlive) {
                 const humanId = players.find(p=>p.isHuman).id;
                 if (!tiedPlayers.includes(humanId)) {
                     votes[humanVoteId]=1;
                     const targetName = players.find(p=>p.id===humanVoteId)?.name || "Unknown";
                     addLog(t.playerVoted.replace('{voter}', players.find(p=>p.isHuman)?.name).replace('{target}', targetName), 'system');
                 }
             }
             updateApiStatus('working'); setSelectedVoteTarget(null); 
             
             const ais = players.filter(p=>!p.isHuman && p.isAlive && !tiedPlayers.includes(p.id));
             for(const p of ais) {
                 const isOnline = p.provider !== ModelProvider.OFFLINE;
                 setThinkingPlayerId(p.id); await delay(isOnline ? 3000 : 300); 
                 const myMemory = aiMemories[p.id] || [];
                 const dec = await LLMService.generateVote(p, players, logs, getKeys(), config.language, getGameInfo(), myMemory, tiedPlayers, addDevLog);
                 setThinkingPlayerId(null);
                 if(dec.targetId) {
                     votes[dec.targetId] = (votes[dec.targetId]||0)+1;
                     addDevLog(`${p.name} Vote`, `Voted for ${players.find(x=>x.id===dec.targetId)?.name}`, dec.reason);
                     const targetName = players.find(x => x.id === dec.targetId)?.name || "Unknown";
                     addLog(t.playerVoted.replace('{voter}', p.name).replace('{target}', targetName), 'system');
                 }
             }
             updateApiStatus('success');
             
             let voteList = [];
             players.forEach(p => { if(votes[p.id]) voteList.push(`${p.name}: ${votes[p.id]} votes`); });
             addLog(voteList.join('\n'), 'vote_summary');
             
             let max=0, winners=[];
             Object.entries(votes).forEach(([targetId, count]) => { 
                 if(count>max) { max=count; winners=[targetId]; }
                 else if(count===max) { winners.push(targetId); }
             });

             if(winners.length === 1) {
                 const v = players.find(p=>p.id===winners[0]);
                 addLog(t.executed.replace('{name}', v?.name).replace('{votes}', max), 'action');
                 const nextP = players.map(p => p.id===winners[0]?{...p, isAlive:false}:p);
                 setPlayers(nextP);
                 if(checkWin(nextP)) return;
                 const seerAlive = nextP.some(p => p.isAlive && p.role === Role.SEER);
                 if (config.includeSeer && seerAlive) setPhase(GamePhase.NIGHT_SEER);
                 else setPhase(GamePhase.NIGHT_ACTION);
                 setTiedPlayers([]); 
             } else {
                 const winnerNames = winners.map(wid => players.find(p=>p.id===wid)?.name).join(', ');
                 const aliveCount = players.filter(p=>p.isAlive).length;
                 const isGlobalTie = winners.length === aliveCount || (winners.length > 2 && max === 1);
                 
                 if (isGlobalTie) {
                     addLog(t.tieGlobal, 'system');
                     setTiedPlayers([]); setPhase(GamePhase.TIE_DISCUSSION); setRoundCount(1);
                     const first = players.findIndex(p=>p.isAlive); setCurrentSpeakerIndex(first>-1?first:0);
                 } else {
                     addLog(t.tieDetected.replace('{names}', winnerNames), 'system');
                     setTiedPlayers(winners); setPhase(GamePhase.TIE_SPEECH);
                     let startIdx = 0;
                     while((!players[startIdx].isAlive || !winners.includes(players[startIdx].id)) && startIdx < players.length) startIdx++;
                     setCurrentSpeakerIndex(startIdx);
                 }
             }
        };

        useEffect(() => {
            if(phase === GamePhase.NIGHT_SEER) {
                addLog("Night falls. The Seer opens their eyes...", 'narrative');
                const seer = players.find(p => p.isAlive && p.role === Role.SEER);
                if (!seer) { setPhase(GamePhase.NIGHT_ACTION); return; }
                if (seer.isHuman) { setIsHumanTurn(true); } 
                else {
                    const aiSeerAction = async () => {
                        updateApiStatus('working'); setThinkingPlayerId(seer.id); await delay(2000);
                        const targetId = await LLMService.generateSeerAction(seer, players, logs, getKeys(), config.language, getGameInfo(), inspectedHistory, addDevLog);
                        const target = players.find(p => p.id === targetId);
                        if (target) {
                            const resultStr = `[NIGHT ${dayCount} CHECK]: Checked ${target.name} => ${target.role}`;
                            setAiMemories(prev => ({ ...prev, [seer.id]: [...(prev[seer.id]||[]), resultStr] }));
                            setInspectedHistory(prev => [...prev, targetId]);
                            addDevLog("Seer Action", `Seer checked ${target.name} -> ${target.role}`);
                        }
                        setThinkingPlayerId(null); updateApiStatus('success'); setPhase(GamePhase.NIGHT_ACTION);
                    };
                    aiSeerAction();
                }
            }
        }, [phase]);

        const handleSeerClick = (targetId) => {
            const target = players.find(p => p.id === targetId);
            if (target) {
                alert(t.seerResult.replace('{name}', target.name).replace('{role}', target.role));
                setInspectedHistory(prev => [...prev, targetId]);
                setIsHumanTurn(false);
                setPhase(GamePhase.NIGHT_ACTION);
            }
        };

        useEffect(() => {
             if(phase===GamePhase.NIGHT_ACTION) {
                 addLog("Werewolves are hunting...", 'narrative');
                 const wolves = players.filter(p=>p.isAlive && p.role===Role.WEREWOLF);
                 if(!wolves.length) { setPhase(GamePhase.DAY_DISCUSSION); return; }
                 if(wolves.some(w=>w.isHuman)) { setIsHumanTurn(true); addLog(t.killPrompt, 'system'); return; }
                 const aiKill = async () => {
                     updateApiStatus('working'); await delay(2000);
                     const id = await LLMService.generateNightAction(wolves[0], players, logs, getKeys(), config.language, getGameInfo(), addDevLog);
                     updateApiStatus('success'); resolveNight(id);
                 };
                 aiKill();
             }
        }, [phase]);

        const resolveNight = (tid) => {
            if(!tid) { addLog("Morning. No deaths.", 'narrative'); } 
            else {
                const v = players.find(p=>p.id===tid);
                addLog(t.foundDead.replace('{name}', v?.name), 'action');
                const nextP = players.map(p=>p.id===tid?{...p, isAlive:false}:p);
                setPlayers(nextP);
                if(checkWin(nextP)) return;
            }
            setDayCount(d=>d+1); setRoundCount(1);
            const f = players.findIndex(p=>p.isAlive); setCurrentSpeakerIndex(f>-1?f:0);
            setPhase(GamePhase.DAY_DISCUSSION);
        };

        if (phase === GamePhase.SETUP) {
            return (
                <div className="min-h-screen bg-[#e5e5e5] text-black flex items-center justify-center p-6 relative font-['Sawarabi_Gothic']">
                    <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-0" />
                    <div className="fixed inset-0 bg-[radial-gradient(#d1d1d1_1px,transparent_1px)] [background-size:40px_40px] opacity-40 z-0" />
                    
                    {/* *** FIX: Added Back to Home Button in Setup *** */}
                    <a href="../index.html" className="fixed top-6 left-6 z-50 bg-black text-white px-6 py-3 font-unbounded font-bold text-xs hover:invert transition-all border-2 border-white shadow-[4px_4px_0px_rgba(0,0,0,0.5)] no-underline flex items-center gap-2">
                        <Icons.ArrowLeft /> {t.backHome || "HOME"}
                    </a>

                    <div className="relative z-10 w-full max-w-5xl bg-white/70 backdrop-blur-xl border-4 border-black p-10 shadow-[24px_24px_0px_#000] overflow-y-auto max-h-[95vh] scrollbar-hide">
                        <div className="border-b-8 border-black pb-6 mb-8 flex justify-between items-end">
                            <div><h1 className="font-unbounded font-black text-6xl leading-[0.85] tracking-tighter uppercase">AI JINROU  GAME<br/>#New Version</h1></div>
                            <div className="flex gap-2">{['zh','ja','en'].map(l=>(<button key={l} onClick={()=>setConfig({...config, language:l})} className={`px-4 py-1 font-unbounded font-black text-[10px] border-2 border-black transition-all ${config.language===l?'bg-black text-white':'hover:bg-black/5'}`}>{l.toUpperCase()}</button>))}</div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-12">
                            <div className="space-y-8">
                                <div className="grid grid-cols-2 gap-4">
                                    <div className="space-y-1"><label className="font-unbounded font-black text-[9px] opacity-40 uppercase">{t.playerCount}</label><input type="number" min="3" max="12" value={config.playerCount} onChange={e=>setConfig({...config, playerCount:parseInt(e.target.value)})} className="w-full border-4 border-black p-3 font-unbounded font-black text-xl" /></div>
                                    <div className="space-y-1"><label className="font-unbounded font-black text-[9px] opacity-40 uppercase">{t.maxRounds}</label><input type="number" min="1" max="10" value={config.maxRounds} onChange={e=>setConfig({...config, maxRounds:parseInt(e.target.value)})} className="w-full border-4 border-black p-3 font-unbounded font-black text-xl" /></div>
                                </div>
                                <div className="flex justify-between items-center border-t-2 border-black pt-4"><span className="font-unbounded font-black text-xs uppercase tracking-widest">{t.includeSeer}</span><input type="checkbox" checked={config.includeSeer} onChange={e=>setConfig({...config, includeSeer:e.target.checked})} className="w-6 h-6 border-4 border-black accent-black" /></div>
                                <div className="space-y-2"><label className="font-unbounded font-black text-[9px] opacity-40 uppercase">{t.playAsChar}</label><div className="flex border-4 border-black"><button onClick={()=>setConfig({...config, humanPlayerId:'yes'})} className={`flex-1 p-3 font-unbounded font-black text-xs ${config.humanPlayerId==='yes'?'bg-black text-white':'bg-transparent'}`}>{t.yes}</button><button onClick={()=>setConfig({...config, humanPlayerId:null})} className={`flex-1 p-3 font-unbounded font-black text-xs ${!config.humanPlayerId?'bg-black text-white':'bg-transparent'}`}>{t.no}</button></div></div>
                                
                                <div className="space-y-4 pt-4 border-t-2 border-black">
                                     {/* Gemini Input Section */}
                                    <div className="space-y-2">
                                        <input type="password" placeholder={t.geminiPlaceholder} value={config.geminiKey} onChange={e=>setConfig({...config, geminiKey:e.target.value})} className="w-full border-4 border-black p-4 font-mono text-sm bg-white" />
                                        
                                        {/* *** FIX: Conditional Rendering for Gemini Models *** */}
                                        {config.geminiKey.length > 5 && (
                                            <div className="animate-in fade-in slide-in-from-top-2 duration-300">
                                                <label className="font-unbounded font-black text-[9px] opacity-40 uppercase tracking-widest block mb-2">{t.geminiLabel}</label>
                                                <div className="grid grid-cols-2 gap-2">
                                                    {GEMINI_MODELS.map(model => (
                                                        <label key={model.id} className="flex items-center gap-2 cursor-pointer border border-black/10 p-2 hover:border-black transition-colors">
                                                            <input type="checkbox" className="accent-black w-4 h-4" checked={config.geminiModels.includes(model.id)} onChange={() => toggleGeminiModel(model.id)} />
                                                            <span className={`font-mono text-[9px] font-bold ${config.geminiModels.includes(model.id) ? '' : 'opacity-50'}`}>{model.name}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    {/* SiliconFlow Input Section */}
                                    <div className="pt-4 border-t border-black/20">
                                        <input type="password" placeholder={t.siliconPlaceholder} value={config.siliconKey} onChange={e=>setConfig({...config, siliconKey:e.target.value})} className="w-full border-4 border-black p-4 font-mono text-sm bg-white" />
                                        <div className="flex items-center justify-between mt-2"><button onClick={testConnection} className="bg-black text-white px-6 py-2 font-unbounded font-black text-[9px] hover:opacity-80 transition-opacity">{t.testConnection}</button><span className="font-mono text-xs font-bold uppercase">{testStatusMsg}</span></div>
                                    </div>
                                </div>
                            </div>
                            <div className="space-y-4">
                                {/* *** FIX: Conditional Rendering for Silicon Models *** */}
                                {config.siliconKey.length > 5 && (
                                    <div className="animate-in fade-in slide-in-from-top-2 duration-300">
                                        <label className="font-unbounded font-black text-[9px] opacity-40 uppercase tracking-widest">{t.siliconLabel}</label>
                                        <div className="grid grid-cols-1 gap-2 max-h-[400px] overflow-y-auto pr-2 scrollbar-hide border-t border-black/10 pt-2">
                                            {SILICON_MODELS.map(model => (
                                                <label key={model.id} className="cursor-pointer group flex items-center justify-between border-2 border-black p-3 hover:border-dashed">
                                                    <input type="checkbox" className="hidden" checked={config.siliconModels.includes(model.id)} onChange={() => toggleModel(model.id)} />
                                                    <span className={`font-mono text-[11px] font-bold ${config.siliconModels.includes(model.id) ? 'line-through opacity-40' : ''}`}>{model.name}</span>
                                                    {config.siliconModels.includes(model.id) ? <Icons.Check /> : <div className="w-4 h-4 border-2 border-black"/>}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                )}
                                <div className="flex items-center gap-2 opacity-50"><input type="checkbox" checked={config.devMode} onChange={e=>setConfig({...config, devMode:e.target.checked})} /><span className="text-[9px] font-unbounded font-black uppercase">{t.devMode}</span></div>
                            </div>
                        </div>
                        <button onClick={startGame} className="w-full mt-10 bg-black text-white p-8 font-unbounded font-black text-4xl hover:invert transition-all active:scale-[0.99] uppercase tracking-tighter shadow-[12px_12px_0px_rgba(0,0,0,0.1)]">{t.startGame}</button>
                    </div>
                </div>
            );
        }

        return (
            <div className="h-screen bg-[#e5e5e5] text-black overflow-hidden flex flex-col md:flex-row relative font-['Sawarabi_Gothic']">
                <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-0" />
                <div className="fixed inset-0 bg-[linear-gradient(rgba(18,16,16,0)_50%,rgba(0,0,0,0.04)_50%)] [background-size:100%_4px] pointer-events-none z-[100]" />

                <div className="w-full md:w-1/3 flex flex-col h-1/2 md:h-full border-r-4 border-black bg-white/40 backdrop-blur-md z-10 relative">
                    <div className="p-5 bg-black text-white flex justify-between items-center font-unbounded font-black text-xs">
                        <div className="flex items-center gap-3"><Icons.Terminal /><h2>{t.villageLog}</h2></div>
                        <span className="bg-white text-black px-2 py-0.5">{t.dayCount.replace('{count}', dayCount)} / {roundCount}R</span>
                    </div>
                    
                    {/* Log Area */}
                    <div className="flex-1 overflow-y-auto p-6 space-y-6 scrollbar-hide font-mono text-xs">
                        {logs.map(log => (
                            <div key={log.id} className={`flex flex-col ${log.type === 'system' ? 'items-center opacity-40 border-y border-black/10 py-2' : log.type === 'vote_summary' ? 'items-center border-4 border-black p-4' : log.senderId === 'USER' ? 'items-end' : 'items-start'}`}>
                                {log.type === 'speech' && <span className="font-unbounded font-black text-[9px] mb-1 opacity-60">[{log.senderName}]</span>}
                                {log.type === 'vote_summary' ? (
                                    <div className="text-center w-full">
                                        <div className="font-unbounded font-black mb-2">{t.voteSummary}</div>
                                        <div className="whitespace-pre-wrap">{log.text}</div>
                                    </div>
                                ) : (
                                    <div className={`px-4 py-3 border-2 border-black ${log.senderId === 'USER' ? 'bg-black text-white' : log.type === 'system' ? 'bg-transparent border-0' : 'bg-white shadow-[6px_6px_0px_#000]'}`}>{log.text}</div>
                                )}
                            </div>
                        ))}
                    </div>

                    {/* Chat Input */}
                    {(phase===GamePhase.DAY_DISCUSSION || phase===GamePhase.TIE_DISCUSSION || (phase===GamePhase.TIE_SPEECH && tiedPlayers.includes(players.find(p=>p.isHuman)?.id))) && isHumanTurn && players.find(p=>p.isHuman)?.isAlive && (
                        <div className="p-4 border-t-4 border-black bg-white flex gap-3">
                            <input type="text" value={humanInput} autoFocus onChange={e=>setHumanInput(e.target.value)} onKeyDown={e=>{if(e.key==='Enter'&&humanInput.trim()){addLog(humanInput,'speech',players.find(p=>p.isHuman)?.name,'USER'); setHumanInput(''); setIsHumanTurn(false); advanceTurn(currentSpeakerIndex, players);}}} placeholder={t.chatPlaceholder} className="flex-1 p-3 border-2 border-black font-bold outline-none" />
                            <button onClick={()=>{if(humanInput.trim()){addLog(humanInput,'speech',players.find(p=>p.isHuman)?.name,'USER'); setHumanInput(''); setIsHumanTurn(false); advanceTurn(currentSpeakerIndex, players);}}} className="bg-black text-white px-8 font-unbounded font-black text-xs hover:invert"><Icons.Send /></button>
                        </div>
                    )}
                </div>

                <div className="flex-1 flex flex-col relative p-12 z-10">
                    <div className="absolute top-8 left-1/2 -translate-x-1/2 bg-black text-white px-10 py-3 font-unbounded font-black text-3xl shadow-[10px_10px_0px_rgba(0,0,0,0.1)]">
                        {phase.includes('NIGHT') ? t.night : phase === GamePhase.DAY_VOTE ? 'VOTING_PHASE' : 'DATA_STREAM'}
                    </div>
                    
                    <div className="flex-1 flex items-center justify-center overflow-y-auto">
                        {/* *** FIX: Responsive Grid to prevent cropping *** */}
                        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-8 w-full max-w-7xl p-4">
                            {players.map((p, idx) => (
                                <PlayerCard 
                                    key={p.id} 
                                    player={p} 
                                    isSpeaking={(phase===GamePhase.DAY_DISCUSSION || phase===GamePhase.TIE_SPEECH || phase===GamePhase.TIE_DISCUSSION) && players.indexOf(p)===currentSpeakerIndex} 
                                    isThinking={p.id === thinkingPlayerId} 
                                    revealRole={!players.some(pl=>pl.isHuman) || phase===GamePhase.GAME_OVER || p.isHuman || (players.find(h=>h.isHuman)?.role===Role.WEREWOLF && p.role===Role.WEREWOLF)} 
                                    language={config.language} 
                                    onClick={() => { 
                                        if(phase===GamePhase.DAY_VOTE && players.find(u=>u.isHuman)?.isAlive && !p.isHuman) {
                                            if (tiedPlayers.length === 0 || tiedPlayers.includes(p.id)) setSelectedVoteTarget(p.id); 
                                        }
                                        if(phase===GamePhase.NIGHT_SEER && isHumanTurn && p.role!==Role.SEER) handleSeerClick(p.id); 
                                        if(phase===GamePhase.NIGHT_ACTION && isHumanTurn && p.role!==Role.WEREWOLF && phase!==GamePhase.NIGHT_SEER) { setIsHumanTurn(false); resolveNight(p.id); }
                                    }} 
                                />
                            ))}
                        </div>
                    </div>

                    {/* Interaction Bar (Voting / Actions) */}
                    {(phase===GamePhase.DAY_VOTE || (phase===GamePhase.NIGHT_ACTION && isHumanTurn) || (phase===GamePhase.NIGHT_SEER && isHumanTurn)) && (
                        <div className="absolute bottom-12 left-1/2 -translate-x-1/2 flex flex-col items-center">
                            {phase === GamePhase.DAY_VOTE && players.find(p=>p.isHuman)?.isAlive && (!tiedPlayers.length || !tiedPlayers.includes(players.find(p=>p.isHuman).id)) ? (
                                selectedVoteTarget ? (
                                    <button onClick={() => handleVoteProcess(selectedVoteTarget)} className="bg-black text-white border-4 border-white px-12 py-4 font-unbounded font-black text-xl hover:scale-105 transition-transform shadow-[0_0_20px_rgba(0,0,0,0.5)]">
                                        {t.confirmVote}: {players.find(p=>p.id===selectedVoteTarget)?.name}
                                    </button>
                                ) : (
                                    <div className="bg-white text-black border-4 border-black px-12 py-4 font-unbounded font-black text-xl animate-pulse">
                                        {t.votePrompt}
                                    </div>
                                )
                            ) : (
                                <div className="bg-black text-white px-12 py-4 font-unbounded font-black text-xl border-4 border-white">
                                    {phase===GamePhase.DAY_VOTE ? t.votingProgress : phase===GamePhase.NIGHT_SEER ? t.seerPrompt : t.killPrompt}
                                </div>
                            )}
                        </div>
                    )}
                    
                    <div className="absolute top-8 right-12 bg-white border border-black px-4 py-1 font-unbounded font-black text-[9px] tracking-widest">BUILD_26.01.2026 // STABLE</div>
                </div>

                {config.devMode && <DevConsole logs={devLogs} t={t} />}

                {phase === GamePhase.GAME_OVER && winner && (
                    <div className="absolute inset-0 bg-black/95 flex flex-col items-center justify-center z-[200] backdrop-blur-xl">
                        <h1 className={`font-unbounded font-black text-[8vw] mb-12 tracking-tighter leading-none text-center ${winner === Role.WEREWOLF ? 'text-red-600' : 'text-green-500'}`}>
                            {winner === Role.WEREWOLF ? t.werewolfWin : t.villagerWin}
                        </h1>
                        {/* *** FIX: Use restartGame instead of reload *** */}
                        <button onClick={restartGame} className="bg-white text-black px-20 py-8 font-unbounded font-black text-3xl hover:invert transition-all border-4 border-white">
                            <Icons.Refresh /> {t.playAgain}
                        </button>
                    </div>
                )}
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

    </script>
</body>
</html>